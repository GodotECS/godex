#pragma once

#include "../ecs.h"
#include "../systems/system.h"
#include "core/templates/local_vector.h"

class World;

struct ExecutionSystemData {
	func_system_execute exe;
	/// Storages that want to be notified at the end of the `System` execution.
	LocalVector<godex::component_id> notify_list_release_write;
};

struct ExecutionStageData {
	/// These systems can run in parallel.
	LocalVector<ExecutionSystemData> systems;
};

class Pipeline {
	bool ready = false;
	bool is_sub_dispatcher = false;
	LocalVector<func_temporary_system_execute> temporary_systems_exe;

	/// Execution information.
	LocalVector<func_get_system_exe_info> systems_info;
	LocalVector<ExecutionSystemData> systems_exe;

	/// List of systems that executes a sub pipeline.
	LocalVector<uint32_t> system_dispatchers;

	/// List of event generated by the systems of this pipeline that are be
	/// cleared at the end of the dispatch.
	LocalVector<uint32_t> event_generator;

public:
	Pipeline();

	void set_is_sub_dispatcher(bool p_sub_dispatcher);
	bool get_is_sub_dispatcher() const;

	/// Add a `TemporarySystem` which is executed untill `true` is returned.
	/// The `TemporarySystems` are always executed in single thread and before
	/// any other `System`.
	void add_temporary_system(func_temporary_system_execute p_func_get_exe_info);
	void add_registered_temporary_system(uint32_t p_id);

	/// Add a system that is registered via `ECS`, usually this function is used
	/// to construct the pipeline using the `ECS` class.
	/// This only difference with `add_system` is the argument type.
	/// Returns the in pipeline ID.
	uint32_t add_registered_system(uint32_t p_id);

	/// Add a system that is not registered via `ECS`. Returns the in pipeline ID.
	uint32_t add_system(func_get_system_exe_info p_func_get_exe_info);

	/// Build the pipelines and makes it ready to dispatch.
	/// You can't modify it anymore, after calling this.
	void build();

	/// Returns `true` if the pipeline is ready.
	bool is_ready() const;

	/// get the systems dependencies. The same `Component` or `Databag` can
	/// be found as mutable and immutable.
	void get_systems_dependencies(SystemExeInfo &p_info) const;

	/// Reset the pipeline.
	void reset();

	/// Prepare the world to be safely dispatched.
	void prepare(World *p_world);

	/// Dispatch the pipeline on the following world.
	void dispatch(World *p_world);
};

// This macro save the user the need to pass a `SystemExeInfo`, indeed it wraps
// the passed function with a labda function that creates a `SystemExeInfo`.
// By defining the same name of the method, the IDE autocomplete shows the method
// name `add_system`, properly + it's impossible use the function directly
// by mistake.
#define add_temporary_system(func)                                       \
	add_temporary_system([](World *p_world) -> bool {                    \
		return SystemBuilder::temporary_system_exec_func(p_world, func); \
	})
