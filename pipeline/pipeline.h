#pragma once

/**
	@author AndreaCatania
*/

#include "../ecs.h"
#include "../systems/system.h"
#include "core/templates/local_vector.h"

class World;

class Pipeline {
	bool ready = false;
	LocalVector<func_temporary_system_execute> temporary_systems_exe;

	LocalVector<func_get_system_exe_info> systems_info;
	LocalVector<func_system_execute> systems_exe;

	LocalVector<uint32_t> system_dispatchers;

	/// List of event generated by the systems of this pipeline that are be
	/// cleared at the end of the dispatch.
	LocalVector<uint32_t> event_generator;

	/// List of component storages that the systems of this pipeline require.
	/// This is used to make sure the storages are all generated at the
	/// begining of each process: Create the storage before the dispatching is a
	/// safe precaution.
	LocalVector<uint32_t> component_generator;

public:
	Pipeline();

	/// Add a `TemporarySystem` which is executed untill `true` is returned.
	/// The `TemporarySystems` are always executed in single thread and before
	/// any other `System`.
	void add_temporary_system(func_temporary_system_execute p_func_get_exe_info);
	void add_registered_temporary_system(uint32_t p_id);

	/// Add a system that is registered via `ECS`, usually this function is used
	/// to construct the pipeline using the `ECS` class.
	/// This only difference with `add_system` is the argument type.
	/// Returns the in pipeline ID.
	uint32_t add_registered_system(uint32_t p_id);

	/// Add a system that is not registered via `ECS`. Returns the in pipeline ID.
	uint32_t add_system(func_get_system_exe_info p_func_get_exe_info);

	/// Build the pipelines and makes it ready to dispatch.
	/// You can't modify it anymore, after calling this.
	void build();

	/// Returns `true` if the pipeline is ready.
	bool is_ready() const;

	/// get the systems dependencies. The same `Component` or `Databag` can
	/// be found as mutable and immutable.
	void get_systems_dependencies(SystemExeInfo &p_info) const;

	/// Reset the pipeline.
	void reset();

	/// Prepare the world to be safely dispatched.
	void prepare(World *p_world);

	/// Dispatch the pipeline on the following world.
	void dispatch(World *p_world);
};

// This macro save the user the need to pass a `SystemExeInfo`, indeed it wraps
// the passed function with a labda function that creates a `SystemExeInfo`.
// By defining the same name of the method, the IDE autocomplete shows the method
// name `add_system`, properly + it's impossible use the function directly
// by mistake.
#define add_temporary_system(func)                                       \
	add_temporary_system([](World *p_world) -> bool {                    \
		return SystemBuilder::temporary_system_exec_func(p_world, func); \
	})

// This macro save the user the need to pass a `SystemExeInfo`, indeed it wraps
// the passed function with a labda function that creates a `SystemExeInfo`.
// By defining the same name of the method, the IDE autocomplete shows the method
// name `add_system`, properly + it's impossible use the function directly
// by mistake.
#define add_system(func)                                            \
	add_system([](SystemExeInfo &r_info) {                          \
		SystemBuilder::get_system_info_from_function(r_info, func); \
		r_info.system_func = [](World *p_world) {                   \
			SystemBuilder::system_exec_func(p_world, func);         \
		};                                                          \
	})
